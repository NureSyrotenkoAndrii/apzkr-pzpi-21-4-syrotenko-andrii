Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для виявлення задимлення у приміщенні та допомоги при евакуації

Студент гр. ПЗПІ-21-4                 _______________________ Сиротенко А.О.  
(підпис)

Керівник роботи                            ___________________ доц.Лещинська І.О.
(підпис)
Роботу захищено «__»_________2024 р.
з оцінкою _________________________

    Комісія:                                     ___________________ доц. Лещинський В.О.
(підпис)
_____________________ доц. Лещинська І.О.
(підпис)
___________________ ст.викл. Сокорчук І.П.
(підпис)


Харків
2024 р.

Харківський національний університет радіоелектроніки  

Факультет комп’ютерних наук            Кафедра програмної інженерії                 
Спеціальність 121 – Інженерія програмного забезпечення                                   
Курс             3           Семестр                                          6                                        
Навчальна дисципліна Архітектура програмного забезпечення                          

ЗАВДАННЯ 
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

                                     Сиротенку Андрію Олександровичу                                      
1. Тема проєкту: Програмна система для виявлення задимлення у приміщенні   та допомоги при евакуації                                                                                                   
2. Термін узгодження курсової роботи  « 25 »    березня  2024 р. 
3. Термін здачі студентом закінченої роботи  «  19  »     серпня              2024 р.  
4. Вихідні дані до проєкту: Програмна система має забезпечити використання пристроїв IoT та програмного забезпечення для завчасного виявлення задимлень у приміщенні та підготовки маршрутів евакуації. Система має бути масштабованою, мати можливість монетизації, мати інструменти для адміністрування та відповідати сучасним вимогам захисту даних. 
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, кодування програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки                                                                                                                             
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси)  ER-модель даних, UML-діаграма розгортання, UML діаграма взаємодії, UML-діаграма прецедентів, UML-діаграма діяльності, UML- діаграма компонентів, UML-діаграма послідовності.


КАЛЕНДАРНИЙ ПЛАН


№	Назва етапу курсової роботи	Термін виконання	Примітка
1	Функціональна специфікація
програмного проєкту	26.02.2024 - 27.03.2024 р.	виконано
2	Проєктування програмного
проєкту	30.03.2024 - 05.04.2024 р.	виконано
3	Кодування програмного проєкту	05.04.2024 - 29.05.2024 р.	виконано
4	Оформлення пояснювальної
записки	30.05.2022 - 05.07.2024 р.	виконано
5	Захист курсової роботи	06.07.2024 - 29.08.2024 р.	


Дата видачі теми проєкту «   27   »         березня         2024 р.  

Керівник                                                                    доц.Лещинська І.О.
  					  	(підпис)  

Завдання прийняв до виконання 
ст.гр. ПЗПІ-21-4                                                         Сиротенко А.О.    
  					  	    (підпис)  


РЕФЕРАТ


Пояснювальна записка до курсової роботи: с. 50, рис. 7, табл. 3, додатки 2, джерел 5.
БЕЗПЕКА, ДИМ, ДОПОМОГА, ЕВАКУАЦІЯ, ЗАДИМЛЕННЯ, МАРШРУТ ЕВАКУАЦІЇ, ПОЖЕЖНА БЕЗПЕКА, ПОПЕРЕДЖЕННЯ, ПРИМІЩЕННЯ.

Об’єктом дослідження є пожежна безпека у приміщеннях, а саме автоматизоване виявлення потенційних пожеж та допомоги при евакуації. Вивчається можливість завчасного виявлення потенційних пожеж та побудови маршруту евакуації відповідно до осередків задимлень.
Метою курсової роботи є розробка системи, яка в режимі реального часу відстежує рівень задимлення у приміщенні та за потреби генерує найшвидший маршрут евакуації з небезпечної ділянки та повідомляє усіх користувачів системи про необхідність покинути будівлю. Програмна система дозволяє зберігати готові плани евакуації для різних поверхів приміщення, а також використовує геодані про розташування будівлі та місцезнаходження розумних пристроїв для візуалізації маршрутів евакуації. Також для аналізу та покращення рівня безпеки система зберігає усі потрібні показники сенсорів.
Методи розробки серверної частини базуються на використанні технології .NET та мови програмування C#. Як база даних використовується PostgreSQL з розширенням PostGIS. Зберігання зображень відбувається за допомогою Amazon S3 сервісу. Програмний код для роботи розумного пристрою написано мовою Python.
У результаті роботи здійснено програмну реалізацію системи виявлення задимлень у приміщенні та допомоги при евакуації. Програмна система складається з серверної частини та смартпристрою.


ЗМІСТ


Вступ	6
1 Аналіз та концептуальне моделювання предметної області	7
1.1 Бізнес-вимоги	7
1.1.1 Бізнес можливості	7
1.1.2 Бізнес цілі та критерії успіху	8
1.1.3 Потреби клієнтів на ринку	9
1.1.4 Бізнес-ризики	10
1.2 Концепція рішення	10
1.2.1 Окреслення концепції	10
1.2.2 Головна функціональність	11
1.2.3 Припущення та залежності	12
1.3 Рамки та обмеження проєкту	13
1.3.1 Рамки первинного випуску	13
1.3.2 Рамки наступних випусків	14
1.3.3 Обмеження та винятки	15
1.4 Бізнес-контекст	16
1.4.1 Профілі зацікавлених сторін	16
1.4.2 Пріоритету проєкту	17
1.4.3 Робоче середовище	18
2 Постановка задачі	20
3 Проєктування програмного проєкту	21
3.1 Проєктування серверної частини	21
3.2 Проєктування IoT частини проєкту	27
4 Кодування програмного проєкту	30
4.1 Кодування серверної частини	30
4.2 Кодування IoT	39
Висновки	41
Перелік джерел посилання	42
Додаток А	43
Додаток Б	48

 
ВСТУП


У світі завжди актуальною є проблема безпеки людини у критичних ситуаціях. Зростання рівня автоматизації та впровадження технологій у робочі приміщення збільшують ймовірність виникнення пожеж та задимлень, що підкреслює необхідність використання систем завчасного виявлення, попередження та допомоги. 
Звичні системи виявлення обмежуються звуковими сигналами та автоматичним гасінням можливих пожеж, що не завжди забезпечує належний рівень захисту людей. Наприклад гучний шум чи ізольованість деяких кімнат можуть нівелювати сигналізацію, що може призвести до трагічних наслідків. Також відсутність конкретних інструкцій та плану евакуації з приміщень призводить до паніки та хаосу, що ускладнює евакуацію. 
У зв’язку з цим створення системи виявлення задимлень і допомоги при евакуації стає не лише актуальним, а й необхідним кроком у забезпеченні безпеки. Система має забезпечити своєчасне виявлення загрози та надання детальних інструкцій та маршрутів евакуації людей. Також реалізація декількох різних форматів подання шляху для виходу з будівлі включно з текстовим та двома варіантами графічного подання. Можливість налаштувати параметри окремого сенсора дозволятиме використовувати систему у різних ситуаціях та для різних умов всередині одної будівлі. Впровадження подібного програмного та апаратного забезпечення є важливим кроком на шляху до підвищення рівня безпеки в сучасному суспільстві, де технології грають все більшу роль у житті кожної людини.


1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-вимоги
1.1.1 Бізнес можливості


Оскільки проблема не є новою, на ринку вже існують компанії, що пропонують впровадження систем виявлення та попередження. Наприклад, компанія "Honeywell Fire-Lite" [1] пропонує роками протестоване рішення для забезпечення пожежної безпеки в приміщеннях. Основна функціональність зосереджена на виявленні диму та джерел тепла з подальшим звуковим та візуальним попередженням. Хоча це рішення надає сучасне обладнання та використовує якісні датчики спостереження, воно не забезпечує повноцінної допомоги під час евакуації. Система не має інтерактивного інтерфейсу з безпечними маршрутами виходу з будівлі, що суттєво знижує її ефективність у критичних ситуаціях, коли кожна секунда має значення.
Іншим прикладом може бути компанія "Bosch Fire Alarm System" [2], яка також пропонує надійний захист від критичних ситуацій. Цей сервіс надає більше різних систем, які відслідковують рівні задимлення та випромінювання тепла, включаючи звичайні датчики та відеокамери для розпізнавання пожеж. Проте ця система не забезпечує інтеграцію з мобільним застосунком та не надає маршрутів евакуації з приміщення, що є вагомим недоліком у сучасних умовах, коли користувачі очікують максимальної зручності та безпеки в один дотик.
Порівнюючи аналоги з системою "SafeEscape", можна сказати, що конкуренти зосереджені лише на виявленні та моніторингу задимлень і можливих джерел пожеж. Сервіс "SafeEscape" додатково пропонує інтерактивний інтерфейс для отримання актуальної інформації про рівень задимлення, функцію побудови оптимальних маршрутів евакуації з урахуванням місць задимлення та аналітичні інструменти для попередження можливих пожеж. Таким чином, "SafeEscape" не тільки виявляє небезпеку, але й допомагає мінімізувати ризики для життя людей, пропонуючи найшвидші та найбезпечніші шляхи евакуації.
Монетизація проєкту включатиме декілька джерел:
а)	Продаж розумних пристроїв та послуги з встановлення;
б)	Додаткові аналітичні інструменти для мобільного застосунку та вебсайту;
в)	Консультаційні послуги щодо впровадження системи та створення маршрутів евакуації.


1.1.2 Бізнес цілі та критерії успіху


Основними бізнес-цілями проєкту є створення надійної та швидкої системи попередження та допомоги під час задимлень. Серед більш конкретних цілей можна виділити наступні:
ВО-1: Розширення штату працівників на 30% за перший рік для забезпечення високого рівня обслуговування та підтримки клієнтів;
ВО-2: Зростання кількості користувачів сервісом на 30% щорічно шляхом активного просування та залучення нових ринків;
ВО-3: Розвиток соціальних мереж для популяризації системи та залучення аудиторії, яка прагне бути в курсі новітніх технологій у сфері безпеки;
ВО-4: Зниження рівня витрат на виробництво на 30% за рік шляхом оптимізації процесів та використання більш ефективних матеріалів;
До критеріїв успіху будуть відноситися:
SC-1: Досягнення 10 тисяч користувачів системи протягом першого року, що стане індикатором успішного виходу на ринок;
SC-2: Мінімальна кількість підписників в соціальних мережах - 120 тисяч, що свідчить про активну зацікавленість аудиторії та високу якість контенту;
SC-3: Досягнення обсягу продажів на суму від 200 тисяч доларів, що забезпечить фінансову стабільність і можливість подальшого розвитку;
SC-4: Отримання понад 90% позитивних відгуків на різних платформах та збереження оцінки на рівні 4.5 – 5 балів за перші роки існування, що підтвердить високу якість продукту та задоволеність користувачів;
SC-5: Залучення не менше 5 корпоративних клієнтів у перший рік роботи, що стане вагомим показником довіри та інтересу до системи серед великих компаній.


1.1.3 Потреби клієнтів на ринку


Сучасні власники приміщень усвідомлюють важливість безпеки у будівлях, де вони працюють, живуть або забезпечують роботою інших. Власники приміщень та керівники організацій дедалі частіше шукають рішення, що не лише забезпечують базовий рівень безпеки, але й надають додаткові можливості для моніторингу та управління. До основних потреб можна віднести:
а)	Люди хочуть бути впевненими, що у разі виникнення задимленості або пожеж система надасть необхідну інформацію щодо місцезнаходження проблемної зони та маршрутів евакуації.
б)	Клієнти очікують, що система оперативно відреагує на небезпеку та збереже час, необхідний для виконання усіх необхідних заходів для забезпечення безпеки людей.
в)	Клієнти хочуть використовувати зручний інтерфейс для слідкування за рівнем задимлення. Також зручність отримання інформації з мобільного застосунку чи вебсайту відіграє важливу роль для користувачів.


1.1.4 Бізнес-ризики


Звісно існують ризики, які перешкоджатимуть розвитку проєкту. Одним з головних є конкуренція на ринку, бо великі компанії мають гарну репутацію та довіру користувачів. Також серйозною проблемою може бути залежність від постачальників компонентів для IoT, адже для забезпечення максимальної безпеки приміщення треба велика кількість датчиків. Ще одним ризиком може стати швидкий розвиток технологій штучного інтелекту, який може надати якіснішу допомогу під час евакуації. Щоб мінімізувати наявні ризики, треба зосередитися на наступних аспектах:
а)	Забезпечення надійності датчиків. Велика кількість якісних сенсорів підвищить репутацію системи;
б)	Покращення алгоритмів побудови маршрутів евакуації. Генерація оптимальних маршрутів може забезпечити більшу довіру до проєкту;
в)	Створити декілька джерел постачання. Це знизить ризик перебоїв у постачанні та допоможе уникнути залежності від одного виробника;
Розвиток соціальних мереж та медіа. Рекламні кампанії та акції, створення цікавого матеріалу для залучення нових клієнтів допоможе закріпитися серед конкурентів на ринку.


1.2 Концепція рішення
1.2.1 Окреслення концепції


Програмна система "SafeEscape" – це комплексне рішення для забезпечення пожежної безпеки приміщень. Метою даного проєкту є своєчасне виявлення задимлення, оперативне сповіщення користувачів про небезпеку та надання найкращих маршрутів евакуації з будівлі. "SafeEscape" може ефективно використовуватися в різних типах приміщень, включаючи приватні будинки, квартири, офісні центри, заводські та складські приміщення.
Система також спрямована на керівників малого, середнього та великого бізнесу, оскільки вона є уніфікованою платформою, яка об'єднує сповіщення про небезпеку, допомогу при евакуації та аналітику рівня задимленості на підприємствах. "SafeEscape" пропонує гнучкі рішення, які можуть бути адаптовані до специфічних потреб кожного об'єкту, забезпечуючи тим самим високий рівень захисту та підвищуючи загальний рівень безпеки.
Система орієнтована на забезпечення максимального рівня безпеки за допомогою чутливих сенсорів, що реагують на найменші зміни в рівні задимлення, та графічної візуалізації даних у режимі реального часу як у мобільному застосунку, так і на вебсайті. Це дозволяє користувачам не тільки оперативно отримувати інформацію про небезпечні ситуації, але й здійснювати моніторинг ситуації у приміщеннях на постійній основі, що є надзвичайно важливим для своєчасного реагування та зниження ризиків.
Цей проєкт є інноваційним рішенням у сфері пожежної безпеки, поєднуючи найсучасніші технології для створення ефективного, надійного та зручного у використанні продукту, що здатен забезпечити спокій та впевненість у безпеці будь-якого приміщення.


1.2.2 Головна функціональність


Головними функціями системи є можливість контролювати рівень задимлення та надання швидкої та якісної допомоги під час евакуації. До ключових функцій відносяться:
MF-1: Реєстрація та авторизація, тобто можливість створювати власний профіль та користуватися ним з різних пристроїв.
MF-2: Можливість редагувати дані про себе в профілі. Користувач може змінити ім’я, пошту та іншу інформацію про себе.
MF-3: Можливість створити будівлю та додати користувачів до неї. Користувач може додати в систему необхідну інформацію про приміщення, щоб отримувати маршрути евакуації та дані з датчиків. Також користувач може додавати людей до свого приміщення.
MF-4: Можливість налаштовувати рівень чутливості датчиків. Користувач може встановити межі норм, щоб система реагувала на критичні рівні задимлення.
MF-5: Перегляд показів з сенсорів для кожної кімнати. В режимі реального часу користувач може переглядати показники рівня диму.
MF-6: Отримати статистику про середній рівень задимлення в кімнаті, на поверху та в приміщенні. Користувач може сформувати звіт, щоб проаналізувати стан будівлі.
MF-7: Можливість редагування інформації про приміщення, окремий поверх чи кімнату. Користувач може вносити зміни до структури будівлі.
MF-8: Отримати маршрут евакуації або допомогу під час критичного рівня задимлення.


1.2.3 Припущення та залежності


До припущень відносяться:
а)	Припускається, що за час розробки не вийде аналогічний сервіс з максимально схожим функціоналом. Подібний розвиток подій може негативно вплинути на позиціювання продукту на ринку та загальний успіх проєкту;
б)	Припускається, що датчики будуть проходити регулярне технічне обслуговування. Регулярне обслуговування включає перевірку, налаштування та заміну датчиків у разі необхідності;
в)	Припускається, що на час розробки не з’являться нові технології, що збільшить час розробки або зроблять систему неактуальною.
г)	Припускається, що користувач надасть хоча б один з потрібних джерел для створення маршруту евакуації (зображення з планами евакуації для різних поверхів, геодані про будівлю, правдиву інформацію про розташування кімнат у будівлі).
Залежності:
а)	Розробка пристрою інтернет речей залежить від стабільності постачання та якості товарів;
б)	Система залежить від з’єднання з мережею інтернет;
в)	Система залежить від роботи операційної системи Android та різних вебсервісів;


1.3 Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску


Первинний випуск включатиме набір функцій, що забезпечує комплексний підхід до пожежної безпеки, дозволяючи користувачам легко керувати різними аспектами системи.
До основних функцій системи належать:
SIR-1: Реєстрація та авторизація користувачів; 
SIR-2: Редагування особистого профілю; 
SIR-3: Створення та видалення приміщення або будівлі; 
SIR-4: Редагування інформації про всі складові приміщення або будівлі; 
SIR-5: Встановлення норм для показів сенсорів задимлення; 
SIR-6: Отримання показників з датчиків в режимі реального часу; 
SIR-7: Зміна рівня спрацювання датчиків; 
SIR-8: Аналіз середнього рівня задимлення; 
SIR-9: Можливість звернення до служби підтримки; 
SIR-10: Операції створення, перегляду, редагування та видалення інформації про сутності системи (для адміністратора); 
SIR-11: Отримання сповіщень про відхилення показників від норми; 
SIR-12: Отримання даних з сенсорів задимлення та контроль за встановленими нормами (для IoT пристрою).


1.3.2 Рамки наступних випусків


У майбутніх випусках системи планується впровадження кількох ключових функцій, які значно підвищать ефективність та зручність використання системи "SafeEscape":
SSR-1: Розширення можливостей сенсорів. У рамках цього пункту планується вдосконалення наявних сенсорів задимлення, щоб вони могли виявляти не лише дим, але й інші показники, такі як температура, вологість, наявність токсичних газів тощо. Це дозволить більш точно визначати потенційні загрози, швидше реагувати на різні ситуації та надавати користувачам ще більш детальну інформацію про умови в приміщеннях. 
SSR-2: Автоматичний виклик різних служб порятунку. Реалізація цієї функції передбачає інтеграцію системи з місцевими службами порятунку, такими як пожежні бригади, поліція та швидка допомога. У випадку виявлення критичної ситуації, система автоматично надсилатиме сигнал тривоги відповідним службам, надаючи їм необхідну інформацію про місцезнаходження та характер загрози. Це значно скоротить час реагування та підвищить шанси на швидке усунення небезпеки, що може врятувати життя та зменшити шкоду.
SSR-3: Можливість об’єднання окремих приміщень у великих будівлях. Ця функція передбачає створення єдиної інтегрованої системи для великих будівель, яка дозволить об'єднувати окремі приміщення в один загальний центр. Це буде особливо корисно для бізнес-центрів, заводів, торговельних комплексів та інших великих об'єктів. Завдяки цьому адміністратори зможуть керувати безпекою всього комплексу, отримувати інформацію про всі приміщення в одному інтерфейсі та координувати дії під час евакуації з урахуванням повної картини ситуації.


1.3.3 Обмеження та винятки


Оскільки покращення безпеки є важливим аспектом для забезпечення комфортного життя, деякі функції, хоч і не включені до поточної версії системи, залишаються бажаними для користувачів. До таких функцій відносяться:
а)	Можливість автоматичного гасіння потенційних пожеж. Ця функція дозволить системі не лише виявляти загрози, але й автоматично реагувати на них, що зменшить ризик поширення пожежі та шкоду.
б)	Можливість впровадження додаткових методів спостереження. Розширення можливостей спостереження, таких як додавання тепловізійних камер, дозволить отримувати більш детальну інформацію про небезпеки.
в)	Можливість розширення дії сенсорів на зовнішню територію. Розширення сенсорів за межі приміщення забезпечить моніторинг зовнішньої території для виявлення загроз.
г)	Залучення технологій ШІ для відеоспостереження. Впровадження відеокамер з використанням штучного інтелекту для розпізнавання потенційних проблемних зон до моменту виникнення небезпечної ситуації.


1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


Таблиця 1 – Профілі зацікавлених сторін
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Індивідуальні споживачі	Безпека будинку та своєчасне оповіщення	Розглядає продукт як засіб для покращення безпеки вдома	Оперативне виявлення місця задимленості та отримання маршруту евакуації	Бюджет, обмежені можливості приміщення
Представники бізнесу	Захист працівників, мінімізація збитків та зменшення репутаційних втрат	Дивиться на систему як на ключовий елемент безпеки	Зменшення втрат, швидке реагування та отримання аналітики	Інтеграція в інфраструктуру та можливий вплив на продукцію
Розробники	Випустити якісний продукт	Розглядає даний проєкт як можливість для заробітку та розвитку	Стабільність роботи системи та отримання досвіду	Час, обмежені знання та ресурси


1.4.2 Пріоритету проєкту


Таблиця 2 – Пріоритети проєкту
Показник	Виконання(етапи)	Обмеження(граничні значення)	Ступінь свободи(допустимий діапазон)
План робіт	Випуск першої версії до 02.05.2024	Розробка серверної частини до 10.05.2024; Розробка IoT до 15.05.2024; Розробка клієнтської частини до 23.05.2024; Розробка мобільного застосунку до 01.06.2024	Терміни порушувати не можна
Функціональність	Всі описані функції мають бути реалізовані в версії 1.0	Розробити до випуску першої версії	Система повинна включати всі функції
Якість	Пошук та виправлення помилок	Всі помилки мають бути виправлені до версії 1.0	Система не повинна мати багів


Продовження таблиці 2 – Пріоритети проєкту
Персонал	Один розробник	Всі складові системи має реалізувати одна людина	Сторонні розробники не мають втручатися в розробку
Ціна	Проєкт має чіткий бюджет	Є певний ліміт для бюджету	Перевищення бюджету допускається на 5%


1.4.3 Робоче середовище


Для розробки серверної частини буде використано мову програмування C# та технологію .NET. Це рішення обумовлене продуктивністю, надійністю та великою кількістю вбудованих інструментів для розробки API. Для написання коду буде використовуватися Visual Studio. Для управляння даними буде використано Entity Framework, оскільки він забезпечує зручну роботу з базою даних, скорочує час розробки та дозволяє уникати більшість помилок. Як база даних буде використовуватися PostgreSQL та розширення PostGIS, що дозволяє зберігати географічні дані. Обрана база даних забезпечує надійність, масштабованість та гарну продуктивність, що є ключовими для проєкту.
Вебсайт буде розроблено за допомогою JavaScript бібліотеки React, бо це доволі ефективний та зручний інструмент для розробки веб-додатків. Також для розробки буде використовуватися HTML, CSS та JavaScript. Кодування відбудеться в Visual Studio Code. Також передбачено використання JWT токенів, React Router для навігації, бібліотека Leaflet.js для візуалізації та роботи з GeoJSON.
Мобільний застосунок буде реалізовано за допомогою мови програмування Kotlin, бо завдяки цьому інструменту можна легко розробити застосунок для Android, адже ця мова має багато вбудованих методів оптимізації написання коду. Також буде використано Android Studio для  втілення та тестування.
Пристрій інтернету речей буде реалізовано на базі Arduino. Код буде написано мовою Python у середовищі програмування PyCharm.


2 ПОСТАНОВКА ЗАДАЧІ


На основі проведеного аналізу та концептуального моделювання предметної області, можна визначити завдання, які повинна реалізовувати програмна система “SafeEscape” для забезпечення виявлення задимлень та допомоги при евакуації.
Функціонал системи включає:
а)	Система повинна підтримувати реєстрацію та авторизацію користувачів, можливість редагування їхніх особистих профілів та систему ролей доступу до різного функціоналу.
б)	Користувачі повинні мати можливість створювати та видаляти інформацію про приміщення (будівля, поверх, кімната, сходи, виходи з будівлі), а також редагувати інформацію про всі складові частини цих об'єктів.
в)	Система повинна забезпечувати отримання показників з датчиків у реальному часі та дозволяти зміну рівня спрацювання сенсорів. Також має бути передбачено можливість аналізувати середній рівень задимлення на рівні усіх складових приміщення.
г)	Система має забезпечувати сповіщення користувачів про відхилення показників від встановлених норм та початок евакуації з приміщення.
д)	Для адміністратора повинні бути реалізовані операції створення, перегляду, редагування та видалення інформації про сутності системи. Це містить в собі управління даними про користувачів, приміщення та налаштування сенсорів.
е)	IoT пристрої повинні отримувати дані з сенсорів задимлення та контролювати відповідність цим даним встановленим нормам. 
Цей функціонал дозволяє системі “SafeEscape” забезпечити комплексний підхід до пожежної безпеки, включаючи управління даними, моніторинг стану приміщень, своєчасне сповіщення користувачів та допомогу при евакуації.


3 ПРОЄКТУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
3.1 Проєктування серверної частини


Для визначення взаємодії користувачів із системою "SafeEscape" була розроблена UML діаграма прецедентів. Ця діаграма відображає функціональні можливості системи для кінцевого користувача. Вона допомагає зрозуміти, які саме можливості взаємодії пропонуються для усіх груп користувачів системи.
Система передбачає наявність чотирьох акторів, а саме: «Гість», «Користувач», «Менеджер будівлі», «Адміністратор» та «Сенсор». Для кожної групи передбачено набір функції, що доступні для використання.
«Гість» – це початковий стан усіх клієнтів програмного застосунку. Він має можливість авторизуватися або зареєструватися для подальшої взаємодії. «Користувач» має увесь головний функціонал системи, тобто він може створювати будівлі з усіма необхідними даними (поверхи, кімнати, сходи, виходи) та налаштовувати параметри цього приміщення, додавати сенсори до кімнат, керувати персональною інформацією, переглядати показники сенсорів та аналітичні звіти, отримувати сповіщення про небезпеку та план евакуації з приміщення. Для користувача, що створив будівлю відкриваються функції актора «Менеджер будівлі» до яких входять редагування інформації про створене приміщення, додавання та видалення користувачів з будівлі.
«Адміністратор» має доступ до усіх відкритих даних в системі та має можливість редагувати їх. Також передбачено можливість блокування профілів окремих користувачів та перегляд аналітичної інформації.
Для актора «Сенсор», що представляє відповідно датчики, які вимірюють рівень задимлення в будівлі, доступні функції отримання конфігурації для початку роботи, тобто порогового значення спрацювання, та надсилання показників своїх вимірів на сервер для подальшої обробки.
Розроблену діаграму прецедентів можна побачити на рисунку 1. Вона допоможе у подальшому проєктуванні системи її складових, а також надасть чітке розуміння функціональних можливостей програмного застосунку.

 
Рисунок 1 – UML діаграма прецедентів

Для розуміння фізичної структури проєкту та способів взаємодії між його елементами було розроблено діаграму розгортання (див. рис. 2). Ця діаграма забезпечує чітке уявлення про те, як різні компоненти системи "SafeEscape" розгорнуті і як вони взаємодіють між собою.
Серверна частина системи реалізована за допомогою ASP.NET Web API [3], що забезпечує основну бізнес-логіку та обробку запитів до системи. Для зручності роботи з даними використовується Entity Framework разом з Npgsql, що дозволяє інтегруватися з PostgreSQL [4]. База даних PostgreSQL зберігає всі структуровані дані про будівлі, приміщення, сенсори та користувачів. Для зберігання медіафайлів, таких як зображення, інтегровано Amazon S3, що дозволяє забезпечити надійне зберігання та доступ до файлів через REST API.
IoT-пристрої, написані на Python, виконують роль збирання даних про рівень задимлення. Вони надсилають зібрані дані на сервер за допомогою HTTP-запитів і прослуховують певний порт для отримання оновлень конфігурації (порогове значення спрацювання).
Серверна частина розроблена таким чином, щоб взаємодіяти зі стороною клієнта за допомогою REST API.

 
Рисунок 2 – UML діаграма розгортання

Діаграма розгортання забезпечує чітке уявлення про фізичне розташування основних елементів системи і їхні взаємодії. Вона ілюструє, як різні компоненти системи взаємодіють між собою, що дозволяє краще зрозуміти загальну архітектуру та можливості системи.
Для того, щоб зобразити зв'язки між сутностями бази даних у системі ", було створено ER-діаграму (див. рис. 3). Вона допомагає представити структуру бази даних, визначити основні сутності, їхні атрибути, а також типи зв'язків між ними.

 
Рисунок 3 – ER діаграма

До схеми бази даних входить 15 елементів, які забезпечують реалізацію усіх функціональних можливостей системи.
До цих компонентів входять наступні елементи:
а)	Користувач. Ця сутність відповідає власне за користувача системи та містить в собі необхідну інформацію про нього, а саме: ім’я, пошту, пароль, нікнейм та технічну інформацію про час створення та оновлення профілю;
б)	Роль. Цей елемент зберігає передбачені ролі в системі (адмін/менеджер);
в)	Користувач_Роль. Ця сутність потрібна для створення зв’язку багато-до-багатьох між моделями Користувач та Роль.
г)	Токен оновлення. Ця модель зберігає інформацію про токен оновлення, який створюється коли користувач авторизується в системі.
д)	Будівля. Ця сутність представляє приміщення в якому встановлено систему та містить назву, адресу та кількість поверхів.
е)	Будівля_Користувач. Ця сутність використовується для забезпечення зв’язку багато-до-багатьох між таблицями про користувачів та будівель.
ж)	Поверх. Ця модель відображає поверхи у приміщеннях та містить в собі інформацію про їх номери та зображення з планами евакуації.
з)	Кімната. Цей елемент відповідає за кімнати на поверхах та зберігають інформацію про їх назву та тип.
и)	Вихід. Ця сутність забезпечує зберігання інформації про основні та аварійні виходи з будівлі.
к)	Сходи. Ця модель відповідає за представлення переходів між поверхами, щоб побудувати маршрут евакуації.
л)	GeoJson дані поверху. Ця сутність  використовується для відображення геоданих поверху, щоб будувати візуалізацію евакуаційних маршрутів.
м)	Відстань між кімнатами. Ця модель зберігає відстані між кімнатами, щоб будувати найкоротші маршрути для виходу.
н)	Сенсор. Цей елемент представляє пристрій, що відповідає за вимірювання та обробку показників задимлення. Він містить інформацію про тип, порогове значення та геодані.
о)	Вимірювання. Ця сутність відображає покази з сенсорів та зберігає час та значення виміру задимлення.
п)	Повідомлення. Цей компонент відповідає за представлення попереджувальних повідомлень та містять в собі текст з планом евакуації, дату створення та статус прочитання.
Ця діаграма спроєктована для реалізації з використанням реляційної бази даних PostgreSQL, що допоможе легко масштабуватися та оброблювати великі обсяги інформації.
Для моделювання кроків, які має виконати система для забезпечення функціональності, було створено діаграму діяльності (див. рис. 4). Вона допомагає визначити сценарій поведінки системи для різних варіантів подій.

 
Рисунок 4 – UML діаграма діяльності

Дана діаграма відображає послідовність дій, які виконує серверна частина для забезпечення головної функції системи – побудова маршруту евакуації. Для коректної роботи програми треба сенсори, що працюють, та приналежність користувача до будівлі. Якщо користувач створив власну або його було додано до раніше доданої будівлі, то сервер отримує показники сенсора, а саме: значення задимлення та чи є перевищення порогового значення. Після аналізу інформації від сенсора, система має два варіанти розвитку. Першим випадком є ситуація, коли перевищення норми не зафіксовано та сервер повертається на крок з отриманням показників. Другий варіант передбачає створення маршруту для евакуації з приміщення, створення відповідного повідомлення та надсилання маршруту до клієнта. Процес є циклічним та завершується на моменті вимкнення системи.


3.2 Проєктування IoT частини проєкту


Для розуміння функцій, які має виконувати розумний пристрій, розроблено розширену версію діаграми прецедентів для сенсора (див. рис. 5). Вона надає чітке уявлення про основні сценарії використання пристрою та допомагає зрозуміти його роль у забезпеченні безпеки в будівлі.

 
Рисунок 5 – UML діаграма прецедентів для IoT

На цій діаграмі є єдиний актор «Сенсор». Щоб забезпечити реалізацію необхідного функціоналу, сенсору має отримати порогове значення від сервера, для можливості проведення аналізу. Також пристрій прослуховує певний порт, щоб отримувати оновлення свого рівня спрацювання, коли користувач вносить відповідні зміни у базу даних. Головною функцією сенсора є отримання показника рівня задимлення, подальше опрацювання отриманих даних та відправка результатів аналізу на сервер для подальшої обробки.
Діаграма послідовності надає чіткого розуміння про процес комунікації різних компонентів системи та життєвого циклу компонентів відносно IoT пристрою. Розроблену діаграму можна побачити на рисунку 6.

 
Рисунок 6 – UML діаграма послідовності

Відповідно до діаграми, сенсор починає свою роботу, коли користувач запускає систему. Першим завданням пристрою є отримання порогового значення від сервера. Після цього він може надсилати показники рівня задимлення до сервера, який в свою чергу зберігає відповідні дані в базі. Також користувач може змінити порогове значення для сенсора, що запустить процес зміни на сервері і базі та відповідно надсилання нового значення на сенсор. Відносно сенсора сервер існує лише деякі проміжки часу, коли він проводить комунікацію з ним. Клієнт та база даних не мають значення для розумного пристрою, адже між ними не існує прямої комунікації.
Варто розглянути роботу сенсора з погляду логічних кроків, що він виконує для досягнення цілі. Для цього можна конкретніше розібрати діаграму діяльності сенсора. Розроблену діаграму можна побачити на рисунку 7.

 
Рисунок 7 – UML діаграма діяльності для IoT

Після початку роботи розумного пристрою, він розділяється на дві паралельні дії: запит на порогове значення та слухання порту. Результат запиту до сервера перевіряється та застосовується отримана відповідь або значення за замовчуванням. Далі він може виконувати головну частину роботи, а саме: отримати значення задимлення, проаналізувати дані та відправити вимірювання до сервера. Одночасно з цим, сенсор прослуховує порт для отримання нового значення рівня спрацювання та продовжує виконувати основні дії.


4 КОДУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
4.1 Кодування серверної частини


Відповідно до проведеного аналізу теми та визначення головних функціональних можливостей, було обрано створити API з використанням архітектури REST, що дозволить задовольнити ключові потреби системи та забезпечити сумісність з різними типами платформ. Також для передачі повідомлень та даних в режимі реального часу було налаштовано WebSocket [5].
Оскільки для розробки використовується технологія .NET, то для забезпечення зв’язку з базою даних вирішено використовувати Entity Framework. Таке рішення дозволить спростити код, але зберегти його ефективність.
Для побудови чіткої та якісної структури проєкту, було використано модифікований шаблон проєктування – MVC, тобто Model-View-Controller. Видозміна полягає в тому, що загальноприйнятий компонент View відсутній на серверні частині. Це пояснюється тим, що розроблений API і буде представленням для користувача, який запитує дані. Також виділено окремі структурний елемент у вигляді сервісів та інтерфейсів. Це зроблено для розмежування бізнес-логіки проєкту від роботи контролерів, що значно покращить можливості підтримки та розширення в майбутньому.
Моделі відповідають за управління даними. Цей рівень відповідає за збереження даних та взаємозв’язок зі сховищем. Відповідно до ER діаграми, в системі є 15 моделей. Також до моделей відносяться  DTO (Data Transfer Object), оскільки це допоможе налаштувати правильну комунікацію з клієнтом та уникнути повернення зайвої інформації у відповіді.
Контролери відповідають за обробку HTTP-запитів від користувача та взаємодіють з сервісами, для отримання необхідних користувачеві даних.
Сервіси та інтерфейси потрібні для реалізації бізнес-логіки від контролерів. Сервіси взаємодіють з моделями та виконують необхідні команди та операції, щоб підготовити інформацію для відповіді.
Одним зі способів для забезпечення безпеки доступу до даних є забезпечення авторизації користувача. Для цього використовується JWT токени. Після успішної спроби увійти в систему, користувач отримує власний токен, який дозволяє йому виконувати запити до сервера та отримувати потрібну інформацію. Також створюється токен оновлення, щоб забезпечити безперебійну взаємодію користувача з сервером, бо основний токен діє всього 1 годину.
Усі сутності системи мають реалізовані CRUD операції, які дозволяють керувати інформацією в базі даних. Для адміністратора системи є спеціальні методи блокування або розблокування профілів користувачів.
Для доступу до редагування інформації про будівлі реалізовано систему ролей. Тобто перед виконанням дій з редагування та видалення записів з бази, що стосуються приміщення, відбувається перевірка на права доступу. Описані дії доступні лише для користувачів, які є менеджерами для будівлі та адміністратору усієї системи.
Одним з головних завдань, які виконує сервер, є побудова шляху евакуації(див. дод. А). Контролер, який отримує результат аналізу рівня задимлення від розумного пристрою, у разі необхідності проводить взаємодію з відповідним сервісом, де реалізовано побудову найкоротшого плану евакуації з будівлі за допомогою алгоритму Дейкстри. Для початку створюється граф усіх можливих зв’язків між кімнатами та відбувається пошук оптимального шляху евакуації, щоб оминути небезпечні ділянки. Оскільки в системі налаштовано використання WebSocket, то у разі виникнення задимлень у різних місцях, користувачі будуть отримувати актуальні шляхи для безпечного виходу з будівлі.
Для реалізації отримання аналітичних даних також створено окремі кінцеві точки. На прикладі отримання середнього рівня задимленості по будівлі (див. дод. А), можна побачити, що за допомогою EF отримуються виміри з усіх сенсорів в будівлі, що мають тип “smoke”, тобто відповідають саме за рівень задимлення, та повертається середнє значення отриманих вимірів. Аналогічний принцип реалізовано для отримання аналітики для поверхів та кімнат.
Оскільки серверна частина розроблялася з використанням REST архітектури, то в для клієнта доступні різні GET, POST, PUT та DELETE запити. Специфікацію розробленого REST API можна переглянути в таблиці 3.

Таблиця 3 – Специфікація REST API для серверної частини
Сутність	Метод	Посилання	Опис
Користувач	GET	api/Users	Отримати список усіх користувачів
		api/Users/{id}	Отримати користувача за id
	POST	api/Auth/authenticate	Авторизуватися
		api/Auth/register	Зареєструватися
		api/Auth/refresh-token	Перевірити токен оновлення
		api/Auth/revoke-token	Відкликати токен оновлення
		api/Users	Додати користувача
	PUT	api/Users/{id}	Редагувати інформацію про користувача (адміністратор)
		api/Users/{id}/update	Редагувати інформацію про користувача(користувач)
		api/Users/{id}/change-password	Змінити пароль
		api/Users/{id}/ban	Заблокувати користувача
		api/Users/{id}/unban	Розблокувати користувача
	DELETE	api/Users/{id}	Видалити користувача
Будівля	GET	api/Building	Отримати усі будівлі
		api/Building/{id}	Отримати будівлю за id

Продовження таблиці 3
Сутність	Метод	Посилання	Опис
Будівля	GET	api/Building/{buildingId}/smoke-statistics	Отримати статистику рівня задимлення будівлі
		api/Building/{buildingId}/users	Отримати усіх користувачів будівлі
		api/Building/{buildingId}/floors	Отримати усі поверхи будівлі
	POST	api/Building	Створити будівлю
	PUT	api/Building/{id}	Редагувати дані про будівлю
	DELETE	api/Building/{id}	Видалити будівлю
Вихід	GET	api/Exits	Отримати усі виходи
		api/Exits{id}	Отримати вихід за id
	POST	api/Exits	Додати вихід
	PUT	api/Exits/{id}	Оновити дані про вихід
	DELETE	api/Exits/{id}	Видалити вихід
Поверх	GET	api/Floors	Отримати усі поверхи
		api/Floors/{id}	Отримати поверх за id

Продовження таблиці 3
Сутність	Метод	Посилання	Опис
Поверх	GET	api/Floors/{floorId}/rooms	Отримати усі кімнати на поверсі
		api/Floors/{floorId}/smoke-statistics	Отримати середнє
задимлення
	POST	api/Floors	Додати поверх
	PUT	api/Floors/{id}	Оновити поверх
	DELETE	api/Floors/{id}	Видалити поверх
Геодані поверху	GET	api/GeoJsonFloorData	Отримати усі геодані
		api/GeoJsonFloorData/{id}	Отримати усі геодані за id
	POST	api/GeoJsonFloorData	Додати геодані
	PUT	api/GeoJsonFloorData/{id}	Оновити геодані за id
	DELETE	api/GeoJsonFloorData/{id}	Видалити геодані
Вимірювання	GET	api/Measurements	Отримати усі виміри
		api/Measurements{id}	Отримати усі вимір за id
		api/sensor/{sensorId}/measurements	Отримати усі виміри сенсора
	POST	api/Measurements	Додати вимір
Продовження таблиці 3
Сутність	Метод	Посилання	Опис
Вимірювання	POST	api/Measurements/receive	Отримати показник сенсора
	PUT	api/Measurements{id}	Оновити вимір
	DELETE	api/Measurements{id}	Видалити вимір
Повідомлення	GET	api/Notifications	Отримати усі повідомлення
		api/Notifications{id}	Отримати повідомлення за id
	POST	api/Notifications	Додати повідомлення
	PUT	api/Notifications{id}	Оновити повідомлення
		api/Notifications{id}/mask-as-read	Позначити повідомлення як прочитане
	DELETE	api/Notifications{id}	Видалити повідомлення
Токен оновлення	GET	api/RefreshTokens	Отримати усі токени оновлення
		api/RefreshTokens{id}	Отримати токен оновлення за id
	POST	api/RefreshTokens	Додати токен оновлення
	PUT	api/RefreshTokens{id}	Оновити токен оновлення
	DELETE	api/RefreshTokens{id}	Видалити токен
Продовження таблиці 3
Сутність	Метод	Посилання	Опис
Роль	GET	api/Roles	Отримати усі ролі
		api/Roles{id}	Отримати роль за id
	POST	api/Roles	Додати роль
	PUT	api/Roles{id}	Оновити роль
	DELETE	api/Roles{id}	Видалити роль
Відстань між кімнатами	GET	api/RoomEdges	Отримати усі відстані
		api/RoomEdges{id}	Отримати відстань за id
		api/RoomEdges{roomId}/evacuation-route	Отримати шлях евакуації
	POST	api/RoomEdges	Додати відстань
	PUT	api/RoomEdges{id}	Оновити відстань
	DELETE	api/RoomEdges{id}	Видалити відстань
Кімната	GET	api/Rooms	Отримати усі кімнати
		api/Rooms{id}	Отримати кімнату за id
		api/buildings/{buildingId}/rooms	Отримати усі кімнати будівлі
		api/rooms/{roomId}/smoke-statistics	Отримати рівень
Продовження таблиці 3
Сутність	Метод	Посилання	Опис
Кімната	GET	api/rooms/{roomId}/smoke-statistics	Отримати середній рівень задимлення
	POST	api/Rooms	Додати кімнату
	PUT	api/Rooms{id}	Оновити кімнату
	DELETE	api/Rooms{id}	Видалити кімнату
Сенсор	GET	api/Sensors	Отримати усі сенсори
		api/Sensors{id}	Отримати  сенсор за id
		api/rooms/{roomId}/sensor	Отримати усі сенсори з кімнати
	POST	api/Sensors	Додати сенсор
	PUT	api/Sensors{id}	Оновити сенсор
		api/Sensors{id}/update-threshold	Оновити порогове значення
	DELETE	api/Sensors{id}	Видалити сенсор
Сходи	GET	api/Stairs	Отримати усі сходи
		api/Stairs{id}	Отримати сходи за id
	POST	api/Stairs	Додати сходи
	PUT	api/Stairs{id}	Оновити сходи
	DELETE	api/Stairs{id}	Видалити сходи
Користувач- Будівля	GET	api/UserBuildings	Отримати усю інформацію
		api/UserBuildings{userId}/{buil
dingId}	Отримати запис користувач-будівля за id
Кінець таблиці 3
Сутність	Метод	Посилання	Опис
Користувач- Будівля	POST	api/UserBuildings	Додати запис користувач-будівля
		api/UserBuildings/add-user	Додати користувача до будівлі
	PUT	api/UserBuildings{userId}/{buil
dingId}	Оновити запит користувач-будівлі
	DELETE	api/UserBuildings{userId}/{buil
dingId}	Видалити користувач-будівлі
Користувач-роль	GET	api/UserRoles	Отримати усі записи користувач-роль
		api/UserRoles/{userId}/{roleId}	Отримати запис користувач-роль за id
	POST	api/UserRoles	Додати запис користувач-роль
	DELETE	api/UserRoles/{userId}/{roleId}	Видалити запис користувач-роль


4.2 Кодування IoT


Розробка програмного забезпечення для розумного пристрою відбувалася мовою Python. Це рішення зумовлене тим, що Python пропонує велику кількість бібліотек для реалізації необхідного функціоналу, має гарну документацію та дозволяє легко масштабувати та підтримувати код.
Структура IoT містить в собі три окремі файли. Перший файл охоплює конфігурацію сенсора, а саме: id пристрою, необхідні посилання для отримання порогового значення та відправки даних на сервер та порт, який прослуховує сервер. 
Другий файл (див. дод. Б) містить усю бізнес-логіку розумного пристрою, яку він має виконувати. У цьому файлі клас сенсора має необхідні методи для забезпечення роботи та виконання потрібних функцій. Метод для отримання рівня чутливості сенсора надсилає відповідний запит до сервера та оброблює отриману відповідь. Можливі два сценарії результату: якщо запит успішний, то сенсор приймає отримане значення та продовжує працювати з ним, у разі коли отримати поріг спрацювання не вийшло, то приймається значення за замовчуванням. 
Оскільки це емулятор роботи IoT пристрою, то метод генерації даних дещо спрощений. Він використовує умовний шанс 1% генерації даних, що перевищують порогове значення. 
Метод для надсилання даних на сервер спочатку перевіряє чи є задимлення у приміщенні, формує дані, що будуть відправлені на сервер та за допомогою посилання з файлу конфігурації відправляє інформацію на сервер. Також для кращого розуміння роботи сенсора, він виводить у консоль усі відправлені дані.
Для оновлення порогового значення використовується метод, який прослуховує певний порт та очікує на отримання нового значення від сервера. Це досягається за допомогою бібліотеки Flask. Щоб оновлювати дані лише для конкретного сенсора відбувається перевірка на збіг id, який приходить від сервера, з ідентифікаційним кодом цього сенсора. Після отримання нового порогового значення відбувається оновлення конфігурації сенсора для подальшої роботи.
Метод для початку роботи сенсора визначає часові проміжки між генерацією умовного рівня диму у кімнаті та слугує метод для запуску сенсора.
Третій файл містить у собі точку входу у програму. Він використовує два потоки, щоб сенсор одночасно генерував і надсилав дані на сервер та прослуховував порт для отримання нового рівня спрацювання. Спочатку відбувається створення екземпляра класу сенсора та налаштування потоків для роботи.


ВИСНОВКИ


Під час виконання курсової роботи було проведено дослідження потреб на сучасному ринку та обрано тему, яка має попит та потенціал до монетизації та розвитку. 
Для обраної теми було проведено концептуальний аналіз предметної області, де визначено потреби, які вирішує розроблена програмна система, можливості потенційного розвитку, усі ризики та обмеження, що можуть стати на заваді розробки проєкту, визначено функціональні потреби системи. Також було проведено проєктування системи на усіх рівнях розробки за допомогою діаграм, що включать фізичне моделювання, визначення сценаріїв поведінки програми та розподілу функціоналу між користувачами.
Для розробки серверної частини було обрано технологію .NET і мову C# та базу даних PosgreSQL. Також використано Amazon S3 сервіс та налаштовано роботу WebSocket. Розумний пристрій реалізовано за допомогою мови Python, бібліотек для роботи з HTTP-запитами та багатопоточністю.
Результатом роботи стала програмна система, що відслідковує рівень задимлення на у приміщеннях та допомагає під час евакуації. Програмний застосунок дозволяє створювати будівлі, налаштовувати сенсори, переглядати аналітичну інформацію про рівень задимлення для різних складових приміщення, отримувати безпечні маршрути евакуації з будівлі у різних форматах. Розроблена система створює додатковий рівень захисту людей та є зручним інструментом для забезпечення безпеки з можливістю аналізу та покращення загального безпекового рівня в приміщені.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	Fire-Lite. Building Automation. URL: https://buildings.honeywell.com/us/en/brands/our-brands/firelite (дата звернення: 10.03.2024).
2.	Fire alarm systems. Bosch Security and Safety Systems I Global. URL: https://www.boschsecurity.com/xc/en/solutions/fire-alarm-systems/ (дата звернення: 10.03.2024).
3.	ASP.NET web API. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/previous-versions/aspnet/hh833994(v=vs.108) (дата звернення: 15.04.2024).
4.	 PostgreSQL 16.4 documentation. PostgreSQL Documentation. URL: https://www.postgresql.org/docs/current/ (дата звернення: 01.04.2024).
5.	WebSockets support in ASP.NET core. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-gb/aspnet/core/fundamentals/websockets?view=aspnetcore-8.0 (date of access: 10.04.2024).


ДОДАТОК А
Програмний код серверної частини


Побудова шляху евакуації
1  // Calculates the evacuation route from a start room to the nearest exit using Dijkstra's algorithm.
2  public async Task<EvacuationRouteResponseDto> GetEvacuationRouteAsync(Guid startRoomId)
3  {
4      var rooms = await _context.Rooms.Include(r => r.RoomEdges1).Include(r => r.RoomEdges2).ToListAsync();
5      var roomEdges = await _context.RoomEdges.ToListAsync();
6      var exits = await _context.Exits.ToListAsync();
7      var stairs = await _context.Stairs.ToListAsync();
8  
9      var graph = new Dictionary<Guid, Dictionary<Guid, int>>();
10     var roomNames = rooms.ToDictionary(r => r.Id, r => r.Name);
11 
12     // Build the graph with room edges.
13     foreach (var edge in roomEdges)
14     {
15         if (!graph.ContainsKey(edge.Room1Id))
16         {
17             graph[edge.Room1Id] = new Dictionary<Guid, int>();
18         }
19         if (!graph.ContainsKey(edge.Room2Id))
20         {
21             graph[edge.Room2Id] = new Dictionary<Guid, int>();
22         }
23         graph[edge.Room1Id][edge.Room2Id] = edge.Distance;
24         graph[edge.Room2Id][edge.Room1Id] = edge.Distance;
25     }
26 
27     // Add stair connections to the graph.
28     foreach (var stair in stairs)
29     {
30         if (!graph.ContainsKey(stair.Floor1RoomId))
31         {
32             graph[stair.Floor1RoomId] = new Dictionary<Guid, int>();
33         }
34         if (!graph.ContainsKey(stair.Floor2RoomId))
35         {
36             graph[stair.Floor2RoomId] = new Dictionary<Guid, int>();
37         }
38         graph[stair.Floor1RoomId][stair.Floor2RoomId] = 1;
39         graph[stair.Floor2RoomId][stair.Floor1RoomId] = 1;
40     }
41 
42     return DijkstraAlgorithm(graph, startRoomId, exits.Select(e => e.RoomId).ToList(), roomNames);
43 }
44 
45 // Dijkstra's algorithm to find the shortest path in the graph.
46 private EvacuationRouteResponseDto DijkstraAlgorithm(Dictionary<Guid, Dictionary<Guid, int>> graph, Guid startRoomId, List<Guid> exitRoomIds, Dictionary<Guid, string> roomNames)
47 {
48     var distances = new Dictionary<Guid, int>();
49     var previous = new Dictionary<Guid, Guid?>();
50     var nodes = new List<Guid>();
51 
52     // Initialize distances and previous node mappings.
53     foreach (var node in graph)
54     {
55         distances[node.Key] = node.Key == startRoomId ? 0 : int.MaxValue;
56         previous[node.Key] = null;
57         nodes.Add(node.Key);
58     }
59 
60     // Dijkstra's algorithm main loop.
61     while (nodes.Count != 0)
62     {
63         nodes.Sort((x, y) => distances[x] - distances[y]);
64         var smallest = nodes[0];
65         nodes.Remove(smallest);
66 
67         if (distances[smallest] == int.MaxValue)
68         {
69             break;
70         }
71 
72         if (exitRoomIds.Contains(smallest))
73         {
74             var path = new List<Guid>();
75             while (previous[smallest] != null)
76             {
77                 path.Add(smallest);
78                 smallest = previous[smallest].Value;
79             }
80 
81             path.Add(startRoomId);
82             path.Reverse();
83 
84             var roomNamesPath = path.Select(roomId => roomNames[roomId]).ToList();
85 
86             return new EvacuationRouteResponseDto
87             {
88                 RoomIds = path,
89                 RoomNames = roomNamesPath,
90                 TotalDistance = distances[path.Last()]
91             };
92         }
93 
94         foreach (var neighbor in graph[smallest])
95         {
96             var alt = distances[smallest] + neighbor.Value;
97             if (alt < distances[neighbor.Key])
98             {
99                 distances[neighbor.Key] = alt;
100                previous[neighbor.Key] = smallest;
101            }
102        }
103    }
104
105    return null;
106}

Отримання статистика задимлення по всій будівлі
1 // Calculates the average smoke level for a given building.
2 public async Task<double> GetSmokeStatisticsAsync(Guid buildingId)
3 {
4     var rooms = await _context.Rooms.Where(r => r.BuildingId == buildingId).Select(r => r.Id).ToListAsync();
5     var measurements = await _context.Measurements
6         .Include(m => m.Sensor)
7         .Where(m => rooms.Contains(m.Sensor.RoomId) && m.Sensor.Type == "smoke")
8         .ToListAsync();
9 
10    if (measurements.Count == 0)
11    {
12        throw new KeyNotFoundException("No smoke measurements found for the specified building");
13    }
14
15    return measurements.Average(m => m.Value); // Calculate average smoke value.
16}


ДОДАТОК Б
Код IoT частини


Клас сенсор, який моделює роботу розумного пристрою
1 import requests
2 import random
3 import time
4 
5 class Sensor:
6     def __init__(self, sensor_id, server_url, threshold_url):
7         self.sensor_id = sensor_id
8         self.server_url = server_url
9         self.threshold_url = threshold_url
10        self.threshold = self.get_threshold()
11        print(f"Initial threshold value: {self.threshold}")
12
13    def get_threshold(self):
14        # Retrieve the current threshold value from the server.
15        response = requests.get(f"{self.server_url}/{self.sensor_id}", verify=False)
16        if response.status_code == 200:
17            return response.json().get('threshold', 50)
18        else:
19            raise Exception(f"Error getting threshold value: {response.status_code}")
20
21    def generate_data(self):
22        if random.random() < 0.01:
23            return self.threshold + random.uniform(1, 10)
24        else:
25            return random.uniform(0, self.threshold)
26
27    def send_data(self, data):
28        is_above_threshold = data > self.threshold
29        payload = {
30            "SensorId": str(self.sensor_id),
31            "Value": data,
32            "IsAboveThreshold": is_above_threshold
33        }
34        # Send the generated sensor data to the server.
35        response = requests.post(f"{self.threshold_url}", json=payload, verify=False)
36        if response.status_code != 200:
37            print(f"Error sending data: {response.status_code}, Message: {response.json()}")
38        else:
39            print(f"Sent: {payload}")
40
41    def run(self):
42        while True:
43            data = self.generate_data()
44            print(f"Generated data: {data}")
45            self.send_data(data)
46            time.sleep(10)
47
48    def update_threshold(self, new_threshold):
49        self.threshold = new_threshold
50        print(f"New threshold value: {self.threshold}")
51
52    def listen_for_updates(self):
53        from flask import Flask, request
54        app = Flask(__name__)
55        # Updates the threshold if the request contains the correct sensor ID.
56
57        @app.route('/update-threshold', methods=['POST'])
58        def update_threshold_route():
59            data = request.json
60            if data.get('sensor_id') == str(self.sensor_id):
61                self.update_threshold(data.get('threshold', self.threshold))
62                return "Threshold updated", 200
63            return "Invalid sensor ID", 400
64
65        app.run(port=8080)
